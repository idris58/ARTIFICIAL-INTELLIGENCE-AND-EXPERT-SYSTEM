# -*- coding: utf-8 -*-
"""F_22-46787-1_Week 06_Updated.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ExBK-kxWmNn-9afhtYJp8rXs7aurRXSH

# N Queen Attack Detection
"""

def drawBoard(P):
  N = len(P)
  for i in range(1,N+1):
    print("|", end="")
    for j in range(1,N+1):
      if (i,j) in P:
        ind = str(1+ P.index((i,j)))
        print(" "+ind+" |", end= "")
      else:
        print(" * |", end= "")
    print()

import math
import random
def generate_positions(N):
    CL = list(range(0,N*N));
    P = []
    for i in range(N):
        p = random.choice(CL)
        CL.remove(p)
        r = math.ceil((p+1)/N)
        c = 1+p%N
        P.append((r,c))
        print('Q{}: {},{}'.format(i+1,r,c))
    return P

generate_positions(4)

generate_positions(4)

N = 4
positions = generate_positions(N)
drawBoard(positions)

# row attack
def rowAttacK(P):
  N = len(P)
  count = 0
  for i in range(N):
    for j in range(i+1,N):
      if P[i][0] == P[j][0]:
        print('row attack:', end = " " )
        print(P[i], end = ", ")
        print(P[j])
        count = count + 1
  return count

rowAttacK(positions)

abs(-2)

#column attack
def columnAttacK(P):
  N = len(P)
  count = 0
  for i in range(N):
    for j in range(i+1,N):
      if P[i][1] == P[j][1]:
        print('column attack:', end = " " )
        print(P[i], end = ", ")
        print(P[j])
        count = count + 1
  return count

columnAttacK(positions)

# diagonal atack
def diagonalAttacK(P):
  N = len(P)
  count = 0
  for i in range(N):
    for j in range(i+1,N):
      if abs(P[i][0] - P[j][0]) == abs(P[i][1] - P[j][1]):
        print('diagonal attack:', end = " " )
        print(P[i], end = ", ")
        print(P[j])
        count = count + 1
  return count

diagonalAttacK(positions)

# implement a method to print a state is valid or not
def isValid(P):
  #row attack
  row_attacks = rowAttacK(P)
  #column attack
  col_attacks = columnAttacK(P)
  #diagonal attack
  diag_attacks = diagonalAttacK(P)

  if row_attacks == 0 and col_attacks == 0 and diag_attacks == 0:
     return True
  else:
    return False
  return True

# call isValid untill you get valid solution
def valid_solution(N):
    while True:
        positions = generate_positions(N)
        if isValid(positions):
            return positions

solution  = valid_solution(4)
print("Valid solution found:")
drawBoard(solution )